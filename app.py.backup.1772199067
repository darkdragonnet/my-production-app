from flask import Flask, jsonify, request
from datetime import datetime
import os
import logging, sqlite3
import requests
import json

# C·∫•u h√¨nh logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ===== KHAI B√ÅO BI·∫æN TO√ÄN C·ª§C =====
DB_FILE = os.path.join(os.path.dirname(__file__), 'webhooks.db')
WEBHOOK_LOG_FILE = os.path.join(os.path.dirname(__file__), 'webhook_log.json')
ZALO_ACCESS_TOKEN = os.getenv('ZALO_ACCESS_TOKEN', 'YOUR_TOKEN_HERE')

app = Flask(__name__)

# ===== KH·ªûI T·∫†O DATABASE =====
def init_db():
    """T·∫°o b·∫£ng webhooks n·∫øu ch∆∞a t·ªìn t·∫°i"""
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS webhooks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                event_name TEXT,
                sender_id TEXT,
                message_text TEXT,
                raw_data TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        conn.commit()
        conn.close()
        logging.info("‚úÖ Database initialized successfully")
    except Exception as e:
        logging.error(f"‚ùå Database initialization error: {e}")

# G·ªçi h√†m kh·ªüi t·∫°o khi app start
init_db()

# ===== H√ÄM HELPER: L·∫§Y TH√îNG TIN PROFILE T·ª™ ZALO API =====
def get_zalo_profile(user_id):
    """
    G·ªçi API Zalo ƒë·ªÉ l·∫•y T√™n v√† Avatar d·ª±a v√†o UID
    
    Args:
        user_id (str): Zalo User ID
        
    Returns:
        dict: {"name": "T√™n ng∆∞·ªùi d√πng", "avatar": "URL avatar"}
    """
    if not ZALO_ACCESS_TOKEN or ZALO_ACCESS_TOKEN == 'YOUR_TOKEN_HERE':
        logger.warning(f"‚ö†Ô∏è ZALO_ACCESS_TOKEN ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh")
        return {"name": "Ch∆∞a c√≥ Token", "avatar": ""}
        
    url = "https://openapi.zalo.me/v2.0/oa/getprofile"
    headers = {"access_token": ZALO_ACCESS_TOKEN}
    params = {"data": json.dumps({"user_id": str(user_id)})}
    
    try:
        res = requests.get(url, headers=headers, params=params, timeout=5)
        if res.status_code == 200:
            data = res.json()
            if data.get("error") == 0:
                profile_data = data.get("data", {})
                return {
                    "name": profile_data.get("display_name", "Kh√¥ng x√°c ƒë·ªãnh"),
                    "avatar": profile_data.get("avatar", "")
                }
            else:
                logger.warning(f"‚ö†Ô∏è Zalo API tr·∫£ v·ªÅ l·ªói {data.get('error')}: {data.get('message')}")
        else:
            logger.error(f"‚ùå Zalo API HTTP {res.status_code}: {res.text}")
    except Exception as e:
        logger.error(f"‚ùå L·ªói khi l·∫•y Zalo Profile cho {user_id}: {e}")
        
    return {"name": "Kh√¥ng x√°c ƒë·ªãnh", "avatar": ""}

# ===== ROUTES =====

@app.route('/')
def home():
    return jsonify({"message": "Zalo Bot API is running!"})

@app.route('/status')
def status():
    """Endpoint ki·ªÉm tra tr·∫°ng th√°i h·ªá th·ªëng"""
    return jsonify({
        "status": "online",
        "bot_status": "active",
        "server_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "version": "1.0.2"
    })

@app.route('/bot-info', methods=['GET'])
def get_bot_info():
    """Endpoint l·∫•y th√¥ng tin Bot t·ª´ Zalo Platform"""
    bot_token = os.getenv("ZALO_BOT_TOKEN")

    if not bot_token:
        return jsonify({"error": "Ch∆∞a c·∫•u h√¨nh ZALO_BOT_TOKEN"}), 500

    url = f"https://bot-api.zaloplatforms.com/bot{bot_token}/getMe"

    try:
        response = requests.post(url, headers={"Content-Type": "application/json"}, timeout=5)

        if response.status_code == 200:
            return jsonify(response.json())
        else:
            logger.error(f"Zalo API tr·∫£ v·ªÅ l·ªói: {response.text}")
            return jsonify({"error": f"L·ªói t·ª´ Zalo: {response.status_code}"}), response.status_code

    except Exception as e:
        logger.error(f"‚ùå L·ªói khi g·ªçi API getMe c·ªßa Zalo: {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/webhook', methods=['POST', 'GET'])
def webhook():
    """Endpoint nh·∫≠n Webhook t·ª´ Zalo"""
    if request.method == 'POST':
        data = request.get_json()
        logger.info(f"üì® Nh·∫≠n Webhook t·ª´ Zalo: {data}")

        # X·ª≠ l√Ω logic webhook ·ªü ƒë√¢y
        # V√≠ d·ª•: L∆∞u tin nh·∫Øn v√†o database, ph√¢n t√≠ch n·ªôi dung, v.v.

        return jsonify({"status": "received", "message": "Webhook processed"})
    return jsonify({"status": "webhook endpoint ready"})

@app.route('/send-message', methods=['POST'])
def send_message():
    """Endpoint g·ª≠i tin nh·∫Øn cho ng∆∞·ªùi d√πng (ƒë∆∞·ª£c g·ªçi b·ªüi Bot Service)"""
    try:
        data = request.get_json()
        recipient_id = data.get("recipient_id")
        message = data.get("message")

        if not recipient_id or not message:
            return jsonify({"error": "Missing recipient_id or message"}), 400

        logger.info(f"üì§ G·ª≠i tin nh·∫Øn cho {recipient_id}: {message}")

        # T·∫°i ƒë√¢y b·∫°n s·∫Ω g·ªçi Zalo API ƒë·ªÉ g·ª≠i tin nh·∫Øn th·ª±c t·∫ø
        # V√≠ d·ª•:
        # zalo_api_response = requests.post(
        #     "https://openapi.zalo.me/v2.0/oa/message/send",
        #     headers={"access_token": ZALO_ACCESS_TOKEN},
        #     json={"recipient": {"user_id": recipient_id}, "message": {"text": message}}
        # )

        return jsonify({
            "status": "success",
            "message": "Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i",
            "recipient_id": recipient_id
        }), 200
    except Exception as e:
        logger.error(f"‚ùå L·ªói khi g·ª≠i tin nh·∫Øn: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/get-messages', methods=['GET'])
def get_messages():
    """Endpoint l·∫•y danh s√°ch tin nh·∫Øn (cho Dashboard)"""
    # Gi·∫£ l·∫≠p d·ªØ li·ªáu - sau n√†y s·∫Ω l·∫•y t·ª´ database
    messages = [
        {
            "time": datetime.now().strftime("%H:%M:%S"),
            "sender": "H·ªá th·ªëng",
            "content": "Bot ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng"
        }
    ]
    return jsonify({"messages": messages})

@app.route('/followers', methods=['GET'])
def get_followers():
    """
    Endpoint l·∫•y danh s√°ch ng∆∞·ªùi d√πng k√®m T√™n v√† Avatar
    
    Response:
    {
        "total_followers": 5,
        "followers": [
            {
                "sender_id": "123456789",
                "last_active": "2025-02-27 20:30:45",
                "interaction_count": 10,
                "name": "Nguy·ªÖn VƒÉn A",
                "avatar": "https://...avatar_url..."
            },
            ...
        ]
    }
    """
    try:
        conn = sqlite3.connect(DB_FILE)
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        
        c.execute("""
            SELECT 
                sender_id, 
                MAX(timestamp) as last_active,
                COUNT(id) as interaction_count
            FROM webhooks 
            WHERE sender_id IS NOT NULL AND sender_id != ''
            GROUP BY sender_id
            ORDER BY last_active DESC
        """)
        rows = c.fetchall()
        conn.close()
        
        followers = []
        for row in rows:
            user_data = dict(row)
            # üîë G·ªçi h√†m l·∫•y profile cho t·ª´ng UID
            logger.info(f"üì• ƒêang l·∫•y profile cho user {user_data['sender_id']}...")
            profile = get_zalo_profile(user_data["sender_id"])
            user_data["name"] = profile["name"]
            user_data["avatar"] = profile["avatar"]
            followers.append(user_data)
            logger.info(f"‚úÖ Profile: {profile['name']} - Avatar: {profile['avatar'][:50]}...")
            
        return jsonify({
            "total_followers": len(followers),
            "followers": followers
        })
    except Exception as e:
        logger.error(f"‚ùå L·ªói l·∫•y danh s√°ch follower: {e}")
        return jsonify({"error": str(e)}), 500


@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Endpoint not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

if __name__ == '__main__':
    logger.info("üöÄ Flask API ƒëang kh·ªüi ƒë·ªông...")
    app.run(host='0.0.0.0', port=5001, debug=False)
